/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////Gerais:

<stats(stat) ::= <<
<if(stat)><stat separator="\n"><endif>
>>

module(name,stat) ::= <<
import random
from os import read

class <name>:
	def main():
        result = Result()

		<stats(stat)>
	
	if __name__ == "__main__":
		main()
>>

exprBinary(value1, op, value2) ::= <<
<value1><op><value2>
>>

exprUnary(value1, op) ::= <<
<op><value1>
>>

pipeExpr(expr1, expr2) ::= <<
(<expr1> | <expr2>)
>>

notExpr(expr1) ::= <<
(not <expr1>)
>>


assign(var,expr) ::= "var <var> = <expr>"

print(expr) ::= "print(<expr>, end='')"

println(expr) ::= "print(<expr>)"

instantiate(class, expr) ::= "<class>(<expr>)"

input(expr) ::= "input(<expr>)"

intConvert(expr) ::= "int(<expr>)"

stringConvert(expr) ::= "str(<expr>)"

for(var, list, stat) ::= <<
for <var> in <list>:
    <stats(stat)>
>>

ifExpr(relacionalExpr, expr, expr2) ::= <<
if <relacionalExpr>:
	<expr>
<if(expr2)>
<elseExpr(expr2)>
<endif>
>>

elseExpr(expr) ::= <<
else:
	<expr>
>>

andExpr(expr1, expr2) ::= <<
(<expr1> and <expr2>)
>>

orExpr(expr1, expr2) ::= <<
(<expr1> or <expr2>)
>>

xorExpr(expr1, expr2) ::= <<
(<expr1> xor <expr2>)
>>

impliesExpr(expr1, expr2) ::= <<
(<expr1> implies <expr2>)
>>


relacionalExpr(var1, condition, var2) ::=<<
(<var1> <condition> <var2>)
>>

elifExpr(relacionalExpr1, expr1, relacionalExpr2, expr2) ::= <<
<ifExpr(relacionalExpr1)>
elif <relacionalExpr2>:
	<expr1>
<if(expr2)>
<elseExpr(expr2)>
<endif>
>>

tryCatch(try_stat, except_stat) ::= <<
try:
    <try_stat>
except Exception as e:
    <except_stat>
>>

writeToFile(filename, data) ::= <<
with open("<filename>", "w") as f:
    f.write(<data>)
>>

Class_str(instance) ::= <<
<instance>.__str__()
>>





/////////////////////////////////////////////////////////////////////////////////////
/////////////////////////Exemplos .py:

InstanciateGroup(varGroup, groupName, childGroups) ::= <<
<varGroup> = Group("<groupName>", [
<childGroups; separator=",\n">
])
>>

childGroup(name, content) ::= <<
Group("<name>", <content>)
>>


RunQuestion(groupName, question) ::= <<
q = <groupname>.getChildren(<question>)
g = q.Answer().Grade()
result.add_result(g)
>>



/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Fraction class

FractionClass() ::= <<
class FractionInt : 
    def __init__(self, num, den):
        self.num = num
        self.den = den
    def __percent__(self):
        return (self.num / self.den) * 100
    def __str__(self):
        return str(self.__percent__()) + "%"
    def __add__(self, other):
        return FractionInt(self.num * other.den + other.num * self.den, self.den * other.den)
    def __sub__(self, other):
        return FractionInt(self.num * other.den - other.num * self.den, self.den * other.den)
    def __prod__(self,other):
        return FractionInt(self.num * other.num,self.den * other.den)
    def __reduce__(self):
        def gcd(a, b):
            while b:
                a, b = b, a % b
            return a
        g = gcd(self.num, self.den)
        return FractionInt(self.num // g, self.den // g)
    def setNum(self,num):
        self.num=num
        return self
    def setDen(self,den):
        self.den=den
        return self
>>
FC_setNum(instance,num) ::= <<
<instance>.setNum(<num>)
>>
FC_setDen(instance,den) ::= <<
<instance>.setDen(<den>)
>>
FC_percent(instance) ::= <<
<instance>.__percent__()
>>
FC_add(instance, other) ::= <<
<instance>.__add__(<other>)
>>
FC_sub(instance, other) ::= <<
<instance>.__sub__(<other>)
>>
FC_prod(instance, other) ::= <<
<instance>.__prod__(<other>)
>>
FC_reduce(instance) ::= <<
<instance>.__reduce__()
>>
FC_value(instance) ::= <<
<instance>.__value__()
>>
FC_Percent(instance) ::= <<
<instance>.__percent__()
>>

/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Result class

ResultClass() ::= <<
class Result:
    def __init__(self, name="result") :
        self.name = name
        self.id = id
        self.result = FractionInt(0,1)
        self.questionsGrades = []
        self.question = []
    def setName(self,name):
        self.name=name
    def getName(self):
        return self.name
    def addQuestion(self,question):
        self.question.append(question)
    def get_result(self):
        tempScore= FractionInt(0,1)
        for q in self.questionsGrades:
            tempScore = tempScore.__add__(q)
        self.result=tempScore.setDen(tempScore.den*len(self.questionsGrades))
        return self.result
    def export_file(self, name="result.txt"):
        with open(name, "w") as file:
            file.write("User: "+self.name + ";\nID: " + str(self.id) + ";\n Grade: " + str(self.result) + "\n")
>>

RC_add_Question(instance, question) ::= <<
<instance>.addQuestion(<question>)
>>
RC_setName(instance, name) ::= <<
<instance>.setName(<name>)
>>
RC_get_result(instance) ::= <<
<instance>.get_result()
>>
RC_getName(instance) ::= <<
<instance>.getName()
>>
RC_export(instance, file) ::= <<
<instance>.export_file(<file>)
>>

/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Question class

QuestionClass() ::= <<
class Question:
    def __init__(self):
        self.autoGrading = False
        self.answer=None
        self.score=FractionInt(0,1)
    def Grade(self):
        # if not self.autoGrading:
        #     print("This is a manual grading question:\n Score: (e.g 10/10)")
        #     info = input()
        #     num = int(info.split('/')[0])
        #     den = int(info.split('/')[1])
        #     score = FractionInt(num,den)
        #     self.score=score.__reduce__()
        #     return score
        return self.score
    def Answer(self):
        self.answer=input(f"Answer the question:")
    def __str__(self):
        return "Esta é uma questão"
>>

QC_Grade(instance) ::= <<
<instance>.Grade()
>>
RC_Answer(instance) ::= <<
<instance>.Answer()
>>


/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Grading class

GradingClass() ::= <<
class Grading():
    def __init__(self):
        self.TotalScore=FractionInt(0,1)
    def getScore(self):
        return self.TotalScore
    def setScore(self,grade):
        self.TotalScore=grade
    def addToScore(self,value:FractionInt):
        self.TotalScore.add(value)
    def __str__(self):
        return str(self.TotalScore)
>>

GC_getScore(instance) ::= <<
<instance>.getScore()
>>
GC_setScore(instance, score) ::= <<
<instance>.setScore(<score>)
>>
GC_addToScore(instance, value) ::= <<
<instance>.addToScore(<value>)
>>


/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////HoleQuestion class

HoleQuestionClass() ::= <<
class HoleQuestion(Question):
    def __init__(self,print):
        # name is the identifier of the question
        # print is the text of the question or the subparts of more then one question,
        super().__init__()
        self.print=print
        self.autograding = True
    def Answer(self):
        for p in self.print:
            p.Answer()
        return self
    def Grade(self):
        for p in self.print:
            sectionG = p.Grade()
            if sectionG.num == 0 and self.score.num == 0:
                self.score.setNum(sectionG.num)
                self.score.setDen(sectionG.den*self.score.den)
                continue
            self.score = self.score.__add__(sectionG)
        return self.score
    def __str__(self):
        return '___'.join([self.questions])
>>

HQC_answerQuestion(instance) ::= <<
<instance>.answerQuestion()
>>
HQC_Grade(instance) ::= <<
<instance>.Grade()
>>


/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////OpenQuestion class

OpenQuestionClass() ::= <<
class OpenQuestion(Question):
    def __init__(self, name,prints):
        super().__init__(name)
        self.prints = prints
        self.answer=None
    def Answer(self):
        for p in self.prints:
            p.Answer()
        self.answer=input(f"Answer here:")
    def __str__(self):
        return '\n'.join([self.questions])
>>

OQC_Answer(instance) ::= <<
<instance>.Answer()
>>



/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////CodeOpenQuestion class

CodeOpenQuestionClass() ::= <<
class CodeOpenQuestion(Question):
    def __init__(self,print,code):
        super().__init__()
        self.print = print
        self.answer=None
        self.code = code
    def Answer(self):
        for p in self.print:
            p.Answer()
        self.code.execute()
        self.answer=input(f"Answer the question (PIL Code):\n")
        return self
    def __str__(self):
        return ''.join([self.print.__str__()])
>>

COQC_Answer(instance) ::= <<
<instance>.Answer()
>>


/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////CodeHoleQuestion class

CodeHoleQuestionClass() ::= <<
class CodeHoleQuestion(Question):
    def __init__(self,print,code,rules=None):
        super().__init__()
        self.autoGrading = True
        self.print = print
        self.grade=FractionInt(0,1)
        self.code = code # this is a code object
        self.rules=rules # if the list of rules is empty does that mean that the question has holes ?
    def Answer(self):
        for p in self.print:
            p.Answer()
        # if len(self.code.elements) == 0 and self.rules is not None:
        #     textCode=[]
        #     for r in self.rules:
        #         self.code.getCode().split(r.rule)
        return self
    def Grade(self):
        g = self.code.Grade(self.rules)
        if isinstance(g, FractionInt) and g.num!=0 and g.den!=1:
            self.grade=g
    def __str__(self):
        return '___'.join([self.questions])
>>

CHQC_Answer(instance) ::= <<
<instance>.Answer()
>>
CHQC_Grade(instance) ::= <<
<instance>.Grade()
>>

/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////MultipleChoiceQuestion class

MultipleChoiceQuestionClass() ::= <<
class MultipleChoiceQuestion(Question):
    def __init__(self,print,code,ops):super().__init__()
        self.code=code
        self.print=print
        self.options=ops
        self.autograding = True
        self.answer=None
        self.correctAnswer=None
        self.input=[] # this is the input for the code it acts as stdin

    def Grade(self):
        if self.correctAnswer is not None and self.answer is not None:
            for choice in self.options:
                if choice.Equals(self.answer) :
                    if self.answer == self.correctAnswer:
                        return FractionInt(1,1)
                    else:
                        return choice.getGrade() if choice.grade != None else 0

    def Answer(self):
        for p in self.print:
            p.Answer()
            for el in p.getElements():
                if isinstance(el,Element) and not (isinstance(el,Hole) or isinstance(el,Choice)):
                    self.input.append(el.getValue())
        print("Select one of the following options:\n")
        for i ,option in enumerate(self.options):
            print(f"{i+1}) {option}")
        pos =-1
        while(pos < 0 or pos>= len(self.options)):
            pos = int(input())-1
        self.answer = self.options[pos].getValue()
        resultCode= self.code.execute(self.input)
        self.correctAnswer= resultCode.lstrip().replace("\n"," ")
        return self
    def __str__(self):
        return "This is a multiple choice question"
>>

MCQC_Answer(instance) ::= <<
<instance>.Answer()
>>
MCQC_Grade(instance) ::= <<
<instance>.Grade()
>>



/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////ComposedQuestion class

ComposedQuestionClass() ::= <<
class ComposedQuestion(Question):
    def __init__(self,questions):
        super().__init__()
        self.questions=questions
    def Answer(self):
        for q in self.questions:
            q.Answer()
        return self
    def Grade(self):
        for q in self.questions:
            self.score.__add__(q.Grade())
    def __str__(self):
        return '___'.join([self.questions.__str__()])
>>

CQC_Answer(instance) ::= <<
<instance>.Answer()
>>
CQC_Grade(instance) ::= <<
<instance>.Grade()
>>


/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Print class

PrintClass() ::= <<
class Print():
    def __init__(self,text,elements=[],ln=False):
        self.elements=elements
        self.text=text
        self.ln= "\n" if ln else ""
        self.points= FractionInt(0,len(elements))
    def getElements(self):
        return self.elements
    def Answer(self):
        text=""
        for i in range(len(self.text)):
            text += self.text[i]
            if i < len(self.elements) and i >=0:
                if isinstance(self.elements[i],Hole):
                    text+="__"
                elif isinstance(self.elements[i],Element):
                    text+=str(self.elements[i].getValue())
        text+=self.ln
        print(text)
        for el in self.elements:
            if isinstance(el,Hole):
                el.Fill()
            elif isinstance(el,Choice):
                pass
    def Grade(self)-> FractionInt:
        numberOfCorrectAns=0
        for el in self.elements:
            if isinstance(el,Hole) and el.isCorrect():
                self.points.setNum(1)
                numberOfCorrectAns +=1
        self.points = self.points.__prod__(FractionInt(numberOfCorrectAns,1))
        return self.points
    def __str__(self):
        #concatenate the text and the sub-elements of the question
        for idx in range(len(self.text)):
            print(self.text[idx]+self.ln)
            if idx < len(self.elements) and idx >=0:
                print(self.elements)


>>

PC_Answer(instance) ::= <<
<instance>.Answer()
>>
PC_Grade(instance) ::= <<
<instance>.Grade()
>>
PC_getElements(instance) ::= <<
<instance>.getElements()
>>

/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Element class

ElementClass() ::= <<
class Element():
    def __init__(self,value=None):
        self.value=value
    def getValue(self):
        return self.value
    def setValue(self,value):
        self.value=value
    def __str__(self):
        return str(self.value)
>>

EC_getValue(instance) ::= <<
<instance>.getValue()
>>
EC_setValue(instance) ::= <<
<instance>.setValue()
>>

/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Rule class

RuleClass() ::= <<
class Rule(Element):
    def __init__(self,rule,grade,line=None):
        super().__init__(rule)
        self.grade=grade
        self.line=line
    def getPoints(self):
        return self.grade
    def __str__(self):
        return self.rule
>>

RC_getPoints(instance) ::= <<
<instance>.getPoints()
>>

/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Hole class

HoleClass() ::= <<
class Hole(Element):
    def __init__(self,validAnswer,id=""):
        super().__init__(validAnswer)
        self.id = id
        self.answer=None
    def getId(self):
        return self.id
    def isAnswered(self):
        return False if self.answer is None else True
    def Fill(self):
        self.answer=input("Write your answer here:").strip()
    def isCorrect(self):
        return self.getValue() == self.answer
    def __str__(self):
        if self.isAnswered:
            return self.answer
        return "__"
>>
HC_getId(instance) ::= <<
<instance>.getId()
>>
HC_isAnswered(instance) ::= <<
<instance>.isAnswered()
>>
HC_Fill(instance) ::= <<
<instance>.Fill()
>>
HC_isCorrect(instance) ::= <<
<instance>.isCorrect()
>>

/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Choice class

ChoiceClass() ::= <<
class Choice(Element):
    def __init__(self, validAnswer:str,grade = None):
        super().__init__(validAnswer)
        self.grade=grade
    def Equals(self,correct):
        if self.getValue() == correct:
            return True
        return False
    def getGrade(self):
        return self.grade
    def __str__(self):
        return self.getValue()
>>

ChoiceC_Equals(instance, correctAnswer) ::= <<
<instance>.Equals(<correctAnswer>)
>>
ChoiceC_getGrade(instance) ::= <<
<instance>.getGrade()
>>


/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Code class

CodeClass() ::= <<
class Code():
    def __init__(self,pil,elements=[]):
        # the name is the identifier of the code
        # the pil is the programming language of the code or parts that are concatenated with the holes for certain types of questions
        # the elements is a list of objects of type 
        self.pil = pil
        self.elements = elements
        self.file = isinstance(self.pil,str) and ".pil" in self.pil
    def getPIL(self):
        return self.pil
    def setElements(self,elements):
        self.elements=elements
    def Answer(self):
        if not self.file and len(self.elements) > 0:
            for el in self.elements:
                if isinstance(el,Hole):
                    el.Fill()
    def Grade(self,rules=None):
        sc = FractionInt(0,1);
        code = self.getCode()
        if rules is not None and isinstance(rules,[Rule]):
            for r in rules:
                sc.setDen(sc.den + r.grade )
                if isinstance(r.rule,str) and r.rule in code:
                    sc.setNum(r.grade)
                elif isinstance(r.rule,Element):
                    identifier = r.rule 
                    for el in self.elements:
                        if isinstance(el,Hole) and identifier == el.id and el.isCorrect():
                            sc.setNum(sc.num + r.grade)
            sc.setDen(sc.den-1) if sc.den != 1 else sc # retira-se por causa da questão da indeterminação 0/0
            return sc
        for el in self.elements:
            sc.setDen(sc.den + 1)
            if isinstance(el,Hole) and el.isCorrect():
                sc.setNum(sc.num + 1)
        sc.setDen(sc.den-1) if sc.den != 1 else sc # retira-se por causa da questão da indeterminação 0/0
        return sc
    def getCode(self):
        pilText=""
        if (self.file):
            with open(self.pil,"r") as file:
                pilText = file.read()
        else:
            for idx,p in enumerate(self.pil):
                pilText += p
                if idx < len(self.elements):
                    el = self.elements[idx]
                    if isinstance(el,Hole) and  not el.isAnswered():
                        pilText+="__"
                    elif isinstance(el,Hole):
                        pilText+=el.answer
        return pilText
    def printCode(self):
        print(self.getCode())
        return self
    def execute(self,stdin=[]):
        PILCodeToRun = InputStream(self.getCode())
        return ''.join(RunCode(PILCodeToRun,stdin))
    def __str__(self):
        return "este é um pedaço de código PIL"
>>

CC_execute(instance, stdin) ::= <<
<instance>.execute(<stdin>)
>>
CC_printCode(instance) ::= <<
<instance>.printCode()
>>
CC_getCode(instance) ::= <<
<instance>.getCode()
>>
CC_getPIL(instance) ::= <<
<instance>.getPIL()
>>
CC_Answer(instance) ::= <<
<instance>.Answer()
>>
CC_Grade(instance, rules) ::= <<
<instance>.Grade(<rules>)
>>
CC_setElements(instance, elements) ::= <<
<instance>.setElements(<elements>)
>>



/////////////////////////////////////////////////////////////////////////////////////////////
////////////////////Group class

GroupClass() ::= <<
class Group:
    def __init__(self, name,children):
        #children is either a list of subGroups or a question
        self.name = name
        self.children = children
    def addChildren(self, child):
        if isinstance(child,Group):
            self.children.append(child)
        elif isinstance(child,Question):
            self.children= child
    def getChildren(self,name:str):
        if isinstance(self.children,Question) or isinstance(self.children,Code):
            return self.children
        for c in self.children:
            if isinstance(c,Group):
                # print(c)
                # print(c.name == name and (isinstance(c.children,Question) or isinstance(c.children,Code)))
                if c.name == name  and (isinstance(c.children,Question) or isinstance(c.children,Code)):
                    return c.children
                elif c.name == name:
                    return c
        return None
    def __str__(self):
        return self.name
>>

GroupC_addChildren(instance, child) ::= <<
<instance>.addChildren(<child>)
>>

GroupC_getChildren(instance, name) ::= <<
<instance>.getChildren(<name>)
>>